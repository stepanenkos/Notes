package kz.stepanenkos.notes.editor.presentationimport android.app.DatePickerDialogimport android.app.TimePickerDialogimport android.content.Contextimport android.os.Bundleimport android.util.Logimport android.view.Viewimport android.widget.CheckBoximport android.widget.ImageViewimport android.widget.TextViewimport androidx.activity.OnBackPressedCallbackimport androidx.fragment.app.Fragmentimport com.google.android.material.snackbar.Snackbarimport com.google.firebase.firestore.FirebaseFirestoreExceptionimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport kz.stepanenkos.notes.Rimport kz.stepanenkos.notes.common.extensions.view.disabledimport kz.stepanenkos.notes.common.extensions.view.enabledimport kz.stepanenkos.notes.common.model.TaskDataimport kz.stepanenkos.notes.common.presentation.ContentEditTextimport kz.stepanenkos.notes.databinding.FragmentEditorTasksBindingimport kz.stepanenkos.notes.listtasks.presentation.TASK_IDimport org.koin.androidx.viewmodel.ext.android.viewModelimport java.util.*class EditorTasksFragment : Fragment(R.layout.fragment_editor_tasks) {    private val editorViewModel: EditorViewModel by viewModel()    private lateinit var binding: FragmentEditorTasksBinding    private lateinit var contentTask: ContentEditText    private lateinit var doneTaskButton: ImageView    private lateinit var editTaskButton: ImageView    private lateinit var setANotificationCheckBox: CheckBox    private lateinit var informationAboutNotificationTextView: TextView    private var taskData: TaskData? = null    private var idTask: Int? = null    private var isSave: Boolean = false    private var timestampOfNotification: Long? = null    override fun onAttach(context: Context) {        super.onAttach(context)        requireActivity().onBackPressedDispatcher.addCallback(            this,            object : OnBackPressedCallback(true) {                override fun handleOnBackPressed() {                    when {                        contentTask.text.toString()                            .isBlank() || isSave || (taskData != null && isEqualsFieldsInTaskDataAndFields()) -> {                            isEnabled = false                            requireActivity().onBackPressed()                        }                        else -> saveTask()                    }                }            })    }    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {        super.onViewCreated(view, savedInstanceState)        binding = FragmentEditorTasksBinding.bind(view)        contentTask = binding.fragmentEditorContentTask        doneTaskButton = binding.fragmentEditorTasksApplyChangedButton        editTaskButton = binding.fragmentEditorTasksEditTextButton        setANotificationCheckBox = binding.fragmentEditorTasksCheckboxSetANotification        informationAboutNotificationTextView =            binding.fragmentEditorTasksTextViewInformationAboutNotification        editTaskButton.disabled()        doneTaskButton.enabled()        idTask = arguments?.getInt(TASK_ID)        idTask?.let { taskById ->            editTaskButton.enabled()            doneTaskButton.disabled()            setANotificationCheckBox.disabled()            editorViewModel.getTaskById(taskById)            isSave = false        }        editorViewModel.taskById.observe(viewLifecycleOwner, ::showTask)        editorViewModel.errorReceiving.observe(viewLifecycleOwner, ::showError)        setOnClickListeners()    }    private fun setOnClickListeners() {        setANotificationCheckBox.setOnCheckedChangeListener { _, checked ->            if (checked && setANotificationCheckBox.isEnabled) {                dateAndTimePickerDialog()            }        }        doneTaskButton.setOnClickListener {            when {                contentTask.text.toString().isBlank() -> {                    Snackbar.make(                        requireView(),                        getString(R.string.editor_tasks_fragment_cannot_save_empty_task),                        Snackbar.LENGTH_LONG                    ).show()                }                else -> saveTask()            }        }        editTaskButton.setOnClickListener {            editTaskUI()        }    }    private fun dateAndTimePickerDialog() {        val calendar = Calendar.getInstance(Locale.getDefault())        val currentYear = calendar.get(Calendar.YEAR)        val currentMonth = calendar.get(Calendar.MONTH)        val currentDay = calendar.get(Calendar.DAY_OF_MONTH)        val currentHour = calendar.get(Calendar.HOUR_OF_DAY)        val currentMinute = calendar.get(Calendar.MINUTE)        val dpd = DatePickerDialog(requireContext(), { _, year, monthOfYear, dayOfMonth ->            val tpd = TimePickerDialog(requireContext(), { _, hourOfDay, minute ->                val selectedTime = Calendar.getInstance(Locale.getDefault())                selectedTime.set(year, monthOfYear, dayOfMonth, hourOfDay, minute)                timestampOfNotification = selectedTime.timeInMillis            }, currentHour, currentMinute, true)            tpd.show()            tpd.setOnCancelListener {                setANotificationCheckBox.isChecked = false            }        }, currentYear, currentMonth, currentDay)        dpd.setOnCancelListener {            setANotificationCheckBox.isChecked = false        }        dpd.show()    }    private fun doneTaskUI() {        contentTask.disabled()        doneTaskButton.disabled()        editTaskButton.enabled()        setANotificationCheckBox.disabled()    }    private fun editTaskUI() {        contentTask.enabled()        doneTaskButton.enabled()        editTaskButton.disabled()        setANotificationCheckBox.enabled()    }    private fun isEqualsFieldsInTaskDataAndFields(): Boolean {        return taskData?.contentTask == contentTask.text.toString() &&                taskData?.notificationOn == setANotificationCheckBox.isChecked &&                taskData?.dateOfNotification == timestampOfNotification    }    private fun showTask(taskData: TaskData?) {        if (taskData != null) {            this.taskData = taskData            setANotificationCheckBox.isChecked = taskData.notificationOn            timestampOfNotification = taskData.dateOfNotification            contentTask.disabled()            contentTask.setText(taskData.contentTask.trim())        }    }    private fun showError(firebaseFirestoreException: FirebaseFirestoreException) {        Snackbar.make(            requireView(),            firebaseFirestoreException.localizedMessage,            Snackbar.LENGTH_LONG        ).show()    }    private fun setOrCancelANotification(taskData: TaskData) {        if (setANotificationCheckBox.isChecked && timestampOfNotification != null) {            editorViewModel.createNotification(taskData)        } else {            editorViewModel.cancelNotification(taskData)        }    }    private fun saveTask() {        when {            taskData == null && contentTask.text.toString().isNotBlank() && !isSave -> {                taskData = if(timestampOfNotification != null) {                    TaskData(                        contentTask = contentTask.text.toString(),                        notificationOn = setANotificationCheckBox.isChecked,                        dateOfNotification = timestampOfNotification!!                    )                } else {                    TaskData(                        contentTask = contentTask.text.toString(),                        notificationOn = setANotificationCheckBox.isChecked,                    )                }                CoroutineScope(Dispatchers.IO).launch {                    taskData?.let {                        editorViewModel.saveTask(                            it                        )                        setOrCancelANotification(it)                    }                    withContext(Dispatchers.Main) {                        Snackbar.make(                            requireView(),                            getString(R.string.editor_tasks_fragment_task_saved),                            Snackbar.LENGTH_LONG                        ).show()                    }                }                doneTaskUI()                isSave = true            }            taskData != null && !isEqualsFieldsInTaskDataAndFields() && !isSave -> {                CoroutineScope(Dispatchers.IO).launch {                    if(timestampOfNotification != null) {                        taskData?.copy(                            contentTask = contentTask.text.toString(),                            notificationOn = setANotificationCheckBox.isChecked,                            dateOfNotification = timestampOfNotification!!                        )?.let {                            editorViewModel.updateTask(                                it                            )                            setOrCancelANotification(it)                        }                    } else {                        taskData?.copy(                            contentTask = contentTask.text.toString(),                            notificationOn = setANotificationCheckBox.isChecked,                        )?.let {                            editorViewModel.updateTask(                                it                            )                            setOrCancelANotification(it)                            withContext(Dispatchers.Main) {                                Snackbar.make(                                    requireView(),                                    getString(R.string.editor_tasks_fragment_task_saved),                                    Snackbar.LENGTH_LONG                                ).show()                            }                        }                    }                }                doneTaskUI()                isSave = true            }        }    }}